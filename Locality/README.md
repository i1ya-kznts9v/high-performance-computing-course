# Лабораторная работа №3

## Задание №A-05

Написать 3 версии программы для матричного умножения:

$C = A * B$, где матрица $A$ прямоугольная и матрица $B$ верхне-треугольная.

Необходимо реализовать 3 версии программы.
1. Умножение матриц как двумерных массивов.
2. Умножение матриц как блочных двумерных массивов.
3. Умножение матриц как блочных одномерных массивов.

Проверить корректность версий программы. Провести численные эксперименты и построить таблицу сравнений времени выполнения различных версий программы. Определить оптимальную размерность блоков для блочного умножения. Сравнить результаты и определить лучшую версию программы.

## Программно-аппаратная конфигурация

```
System:
  Distro: Ubuntu 22.04.4 LTS (Jammy Jellyfish)
  Kernel: 5.15.0-122-generic x86_64
  Bits: 64
  Compiler: GCC 11.4.0
  Interpreter: Python 3.10.12

CPU:
  Model: Intel Xeon E-2136
  Architecture: Coffee Lake
  Cores: 6-core
  Bits: 64
  Speed (MHz):
    Min: 800
    Max: 4500
  Cache:
    L1: 384 KiB
    L2: 1.5 MiB
    L3: 12 MiB
  Flags: 
    avx avx2 ht lm nx pae
    sse sse2 sse3 sse4_1
    sse4_2 ssse3 vmx

RAM:
  Total: 62.67 GiB
```

## Команды

Компиляция и запуск матричного умножения. Результатом являются данные о времени умножения для разных размерностей матриц и блоков в формате `CSV`.

```
gcc -fopenmp -O3 -I. [version].c matrix.c -o [version]
./[version]
```

## Решение

Во всех версиях программы основная логика для работы с матрицами выделена в библиотеку `matrix`, за счет чего эксперименты реализованы отдельными программами.

Матрицы бывают могут храниться как двумерные или одномерные массивы, как нормально, так и блочно. Над ними определены операции создания, заполнения, удаления, работы с индексами, конвертации и умножения - как нормально, так и блочного.

Программы будут хранить в описанных форматах прямоугольные (квадратные) и квадратные верхне-треугольные матрицы. Это требует совпадения размерностей $[dim1, dim2] * [dim2, dim2]$. При этом в операциях пропускаются нулевые элементы верхне-треугольной матрицы, поэтому лишних обращений в память не происходит.

### `simple_2d_array`

Данная версия программы производит умножение матриц, хранящихся в памяти как двумерный массив. Умножение происходит стандартным методом "строка на столбец".

### `blocked_2d_array`

Данная версия программы производит блочное умножение матриц, хранящихся в памяти как двумерный массив. Блочное расположение матриц в памяти позволяет локализовать обращения, что обеспечивает большое количество попаданий в кеш процессора. Однако размерность блоков должна выбираться динамически, поскольку зависит от объёма кеша `L1` у конкретного процессора.

### `blocked_1d_array`

Данная версия программы производит блочное умножение матриц, хранящихся в памяти как одномерный массив. Переход между двумерным и одномерным представлением происходит по формуле $2d\_array[i, j] = 1d\_array[j * (j + 1) / 2 + i]$. По сравнению с `blocked_2d_array`, одномерный массив позволяет улучшить попадания в кеш и снизить фрагментацию памяти. Это связано с тем, что данные загружаются в кеш блоками.

### Корректность

Результирующая матрица из `simple_2d_array` используется как эталон для проверки корректности других версий программы. Точность сравнения чисел `double` - $6$ знаков после запятой. В случае несовпадения чисел, программа завершается с ошибкой. Это гарантирует, что результаты всех версий программы совпадают при одинаковом `seed` во псевдослучайной генерации.

## Результаты

Во всех экспериментах первая размерность матрицы $А$ $dim1 = 1024$, а вторая размерность матрицы $A$ и $B$ $dim2$ пробегается по значениям $[1024, 2048, 2880]$. В случае блочного умножения, размерность блоков меняется по значениям $[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]$ и по значениям $[1, 2, 4, 8, 16, 32, 64, 144, 288, 576, 1440]$. Усреднение результатов происходит по $5$ замерам.

### `simple_2d_array`

Таблица 1: время выполнения `simple_2d_array`.

| Dim 1 | Dim 2 | Time (sec.) |
|-------|-------|-------------|
| 1024  | 1024  | 2.64        |
| 1024  | 2048  | 59.41       |
| 1024  | 2880  | 117.26      |

Является самой медленной версией программы.

### `blocked_2d_array`

Таблица 2: время выполнения `blocked_2d_array`.

| Dim 1 | Dim 2 | Block | Time (sec.) |
|-------|-------|-------|-------------|
| 1024  | 1024  | 1     | 5.27        |
| 1024  | 1024  | 2     | 1.80        |
| 1024  | 1024  | 4     | 0.81        |
| 1024  | 1024  | 8     | 0.64        |
| 1024  | 1024  | 16    | 0.52        |
| 1024  | 1024  | 32    | 0.51        |
| 1024  | 1024  | 64    | 0.51        |
| 1024  | 1024  | 128   | 0.50        |
| 1024  | 1024  | 256   | 0.70        |
| 1024  | 1024  | 512   | 0.82        |
| 1024  | 1024  | 1024  | 1.03        |
| 1024  | 2048  | 1     | 55.32       |
| 1024  | 2048  | 2     | 23.94       |
| 1024  | 2048  | 4     | 8.61        |
| 1024  | 2048  | 8     | 5.08        |
| 1024  | 2048  | 16    | 4.45        |
| 1024  | 2048  | 32    | 4.18        |
| 1024  | 2048  | 64    | 4.17        |
| 1024  | 2048  | 128   | 4.08        |
| 1024  | 2048  | 256   | 4.37        |
| 1024  | 2048  | 512   | 6.76        |
| 1024  | 2048  | 1024  | 9.49        |
| 1024  | 2880  | 1     | 133.75      |
| 1024  | 2880  | 2     | 64.56       |
| 1024  | 2880  | 4     | 24.99       |
| 1024  | 2880  | 8     | 16.51       |
| 1024  | 2880  | 16    | 13.06       |
| 1024  | 2880  | 32    | 13.20       |
| 1024  | 2880  | 64    | 13.43       |
| 1024  | 2880  | 144   | 13.15       |
| 1024  | 2880  | 288   | 16.08       |
| 1024  | 2880  | 576   | 20.29       |
| 1024  | 2880  | 1440  | 97.29       |

### `blocked_1d_array`

Таблица 3: время выполнения `blocked_1d_array`.

| Dim 1 | Dim 2 | Block | Time (sec.) |
|-------|-------|-------|-------------|
| 1024  | 1024  | 1     | 6.94        |
| 1024  | 1024  | 2     | 1.37        |
| 1024  | 1024  | 4     | 0.54        |
| 1024  | 1024  | 8     | 0.32        |
| 1024  | 1024  | 16    | 0.30        |
| 1024  | 1024  | 32    | 0.31        |
| 1024  | 1024  | 64    | 0.29        |
| 1024  | 1024  | 128   | 0.26        |
| 1024  | 1024  | 256   | 0.50        |
| 1024  | 1024  | 512   | 1.35        |
| 1024  | 1024  | 1024  | 2.04        |
| 1024  | 2048  | 1     | 64.90       |
| 1024  | 2048  | 2     | 13.03       |
| 1024  | 2048  | 4     | 5.57        |
| 1024  | 2048  | 8     | 2.69        |
| 1024  | 2048  | 16    | 2.44        |
| 1024  | 2048  | 32    | 2.28        |
| 1024  | 2048  | 64    | 2.19        |
| 1024  | 2048  | 128   | 2.08        |
| 1024  | 2048  | 256   | 3.65        |
| 1024  | 2048  | 512   | 8.95        |
| 1024  | 2048  | 1024  | 14.47       |
| 1024  | 2880  | 1     | 150.31      |
| 1024  | 2880  | 2     | 31.77       |
| 1024  | 2880  | 4     | 13.70       |
| 1024  | 2880  | 8     | 7.33        |
| 1024  | 2880  | 16    | 5.83        |
| 1024  | 2880  | 32    | 5.78        |
| 1024  | 2880  | 64    | 5.51        |
| 1024  | 2880  | 144   | 7.98        |
| 1024  | 2880  | 288   | 11.16       |
| 1024  | 2880  | 576   | 13.55       |
| 1024  | 2880  | 1440  | 23.41       |

Является самой быстрой версией программы.

### Оптимальная размерность блока

Оптимальная размерность блоков зависит от объёма кеша `L1` у конкретного процессора. На данной машине `L1 = 384 KiB`. Как можно увидеть на таблицах, оптимальная размерность блоков лежит в диапазоне $[[16, 16], [128, 128]]$. Блоки размерностью менее $[16, 16]$ и более $[128, 128]$ не являются оптимальными, поскольку время начинает расти, так как блоки матриц не помещаются в кеш и возникают обращения к более медленной памяти.

## Выводы

Таким образом, наибольшее ускорение $117.26 / 5.51 = 21.3$ раза удалось достичь в `blocked_1d_array` по сравнению с `simple_2d_array` для матриц размерностью $[1024, 2880]$ за счёт умножения матриц блоками размерностью $64$, совмещенного с хранением в одномерном массиве. Кроме того, было установлено, что на данной машине оптимальные значения размерности блоков лежат в диапазоне $[[16, 16], [128, 128]]$.
