# Лабораторная работа №3

## Задание №A-05

Написать 3 версии программы для матричного умножения:

$C = A * B$, где матрица $A$ прямоугольная и матрица $B$ верхне-треугольная.

Необходимо реализовать 3 версии программы.
1. Умножение матриц как двумерных массивов.
2. Умножение матриц как блочных двумерных массивов.
3. Умножение матриц как блочных одномерных массивов.

Проверить корректность версий программы. Провести численные эксперименты и построить таблицу сравнений времени выполнения различных версий программы. Определить оптимальную размерность блоков для блочного умножения. Сравнить результаты и определить лучшую версию программы.

## Программно-аппаратная конфигурация

```
System:
  Distro: Ubuntu 22.04.4 LTS (Jammy Jellyfish)
  Kernel: 5.15.0-122-generic x86_64
  Bits: 64
  Compiler: GCC 11.4.0
  Interpreter: Python 3.10.12

CPU:
  Model: Intel Xeon E-2136
  Architecture: Coffee Lake
  Cores: 6-core
  Bits: 64
  Speed (MHz):
    Min: 800
    Max: 4500
  Cache:
    L1: 384 KiB
    L2: 1.5 MiB
    L3: 12 MiB
  Flags: 
    avx avx2 ht lm nx pae
    sse sse2 sse3 sse4_1
    sse4_2 ssse3 vmx

RAM:
  Total: 62.67 GiB
```

## Команды

Компиляция и запуск матричного умножения. Результатом являются данные о времени умножения для разных размерностей матриц и блоков в формате `CSV`.

```
gcc -fopenmp -O3 -I. [version].c matrix.c -o [version]
./[version]
```

## Решение

Во всех версиях программы основная логика для работы с матрицами выделена в библиотеку `matrix`, за счет чего эксперименты реализованы отдельными программами.

Матрицы бывают могут храниться как двумерные или одномерные массивы, как нормально, так и блочно. Над ними определены операции создания, заполнения, удаления, работы с индексами, конвертации и умножения - как нормально, так и блочного.

Программы будут хранить в описанных форматах прямоугольные и квадратные верхне-треугольные матрицы. Это требует совпадения размерностей $[dim1, dim2] * [dim2, dim2]$. При этом в операциях пропускаются нулевые элементы верхне-треугольной матрицы, поэтому лишних обращений в память не происходит.

### `simple_2d_array`

Данная версия программы производит умножение матриц, хранящихся в памяти как двумерный массив. Умножение происходит стандартным методом "строка на столбец".

### `blocked_2d_array`

Данная версия программы производит блочное умножение матриц, хранящихся в памяти как двумерный массив. Блочное расположение матриц в памяти позволяет локализовать обращения, что обеспечивает большое количество попаданий в кеш процессора. Однако размерность блоков должна выбираться динамически, поскольку зависит от объёма кеша `L1` у конкретного процессора.

### `blocked_1d_array`

Данная версия программы производит блочное умножение матриц, хранящихся в памяти как одномерный массив. По сравнению с `blocked_2d_array`, одномерный массив позволяет улучшить попадания в кеш и снизить фрагментацию памяти. Это связано с тем, что данные загружаются в кеш блоками.

### Корректность

Результирующая матрица из `simple_2d_array` используется как эталон для проверки корректности других версий программы. Точность сравнения чисел `double` - $6$ знаков после запятой. В случае несовпадения чисел, программа завершается с ошибкой. Это гарантирует, что результаты всех версий программы совпадают при одинаковом `seed` во псевдослучайной генерации.

## Результаты

Во всех экспериментах первая размерность матрицы $А$ $dim1 = 1024$, а вторая размерность матрицы $A$ и $B$ $dim2$ пробегается по степеням двойки $[512, 2048, *=2]$. В случае блочного умножения, размерность блоков меняется по степеням двойки в диапазоне $[8, 256, *=2]$. Усреднение результатов происходит по $5$ замерам.

### `simple_2d_array`

Таблица 1: время выполнения `simple_2d_array`.

| Dimension 1 | Dimension 2 | Time (sec.) |
|-------------|-------------|-------------|
| 1024        | 512         | 0.48        |
| 1024        | 1024        | 4.89        |
| 1024        | 2048        | 65.12       |

Является самой медленной версией программы.

### `blocked_2d_array`

Таблица 2: время выполнения `blocked_2d_array`.

| Dim 1 | Dim 2 | Block | Time (sec.) |
|-------|-------|-------|-------------|
| 1024  | 512   | 8     | 0.07        |
| 1024  | 512   | 16    | 0.07        |
| 1024  | 512   | 32    | 0.06        |
| 1024  | 512   | 64    | 0.07        |
| 1024  | 512   | 128   | 0.06        |
| 1024  | 512   | 256   | 0.06        |
| 1024  | 1024  | 8     | 0.57        |
| 1024  | 1024  | 16    | 0.51        |
| 1024  | 1024  | 32    | 0.50        |
| 1024  | 1024  | 64    | 0.51        |
| 1024  | 1024  | 128   | 0.50        |
| 1024  | 1024  | 256   | 0.92        |
| 1024  | 2048  | 8     | 5.05        |
| 1024  | 2048  | 16    | 4.41        |
| 1024  | 2048  | 32    | 4.19        |
| 1024  | 2048  | 64    | 4.17        |
| 1024  | 2048  | 128   | 4.12        |
| 1024  | 2048  | 256   | 4.50        |

### `blocked_1d_array`

Таблица 3: время выполнения `blocked_1d_array`.

| Dim 1 | Dim 2 | Block | Time (sec.) |
|-------|-------|-------|-------------|
| 1024  | 512   | 8     | 0.04        |
| 1024  | 512   | 16    | 0.03        |
| 1024  | 512   | 32    | 0.04        |
| 1024  | 512   | 64    | 0.04        |
| 1024  | 512   | 128   | 0.07        |
| 1024  | 512   | 256   | 0.08        |
| 1024  | 1024  | 8     | 0.32        |
| 1024  | 1024  | 16    | 0.25        |
| 1024  | 1024  | 32    | 0.26        |
| 1024  | 1024  | 64    | 0.32        |
| 1024  | 1024  | 128   | 0.39        |
| 1024  | 1024  | 256   | 0.51        |
| 1024  | 2048  | 8     | 2.68        |
| 1024  | 2048  | 16    | 2.65        |
| 1024  | 2048  | 32    | 2.67        |
| 1024  | 2048  | 64    | 3.06        |
| 1024  | 2048  | 128   | 3.60        |
| 1024  | 2048  | 256   | 4.46        |

Является самой быстрой версией программы.

### Оптимальная размерность блока

Оптимальная размерность блоков зависит от объёма кеша `L1` у конкретного процессора. На данной машине `L1 = 384 KiB`, и, как можно увидеть на таблицах, оптимальная размерность блоков не превышает $[128, 128]$. Начиная с $[256, 256]$, время снова начинает расти, поскольку блоки матриц не помещаются в кеш и возникают обращения к более медленной памяти.

## Выводы

Таким образом, наибольшее ускорение $65.12 / 2.65 = 24.5$ раза удалось достичь в `blocked_1d_array` по сравнению с `simple_2d_array` для матриц размерностью $[1024, 2048]$ за счёт умножения матриц блоками размерностью $16$, совмещенного с хранением в одномерном массиве. Кроме того, было установлено, что на данной машине оптимальные значения размерности блоков не превышают $[128, 128]$, а больше - уже вредят производительности программы.
